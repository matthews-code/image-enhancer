import time, random, queue, threading

queue=queue.Queue() #creates the queue
COUNT=20
consumer_threads=2 #sets the number of consumer
producer_threads=2 #sets the number of producer

class producer (threading.Thread):
    def __init__(self, count,thread_ID):
        threading.Thread.__init__(self)
        self.counter=int((count/producer_threads))
        self.list=[]
        self.ID=thread_ID
    def run(self):
        global queue
        time.sleep(3)
        print("Producer is waking %i..\n"%(self.ID))
        i=(self.ID*10)
        for i in range (self.ID*10, ((self.ID*10)+self.counter)):
            print("Producer %i appended an item \n"%(self.ID))
            queue.put(i) #signals another thread to wake-up and get data
            self.list.append(i)
            time.sleep(random.randint(0,2))
        print ("The values generated by producer "+ str(self.ID) +" are "+str(self.list)+"\r\n")

class consumer (threading.Thread):
    def __init__(self, count, thread_ID):
        threading.Thread.__init__(self)
        self.counter=int((count/consumer_threads))
        self.list=[]
        self.item=0
        self.ID=thread_ID
    def run(self):
        global queue
        print("Consumer %i is waiting \n"%(self.ID))
        for i in range(self.counter):
            self.item=queue.get()
            self.list.append(self.item)
            print ("Consumer %i got an item \n"%(self.ID))
            time.sleep(random.randint(0,2))
        print ("The values acquired by consumer "+ str(self.ID) +" are "+str(self.list)+"\r\n")

if __name__=="__main__":
    c_threads_list=[]
    p_threads_list=[]

    for n in range(consumer_threads):
        c=consumer(COUNT,n)
        c_threads_list.append(c)
        c.start()

    for n in range(producer_threads):
        p=producer(COUNT,n)
        p_threads_list.append(p)
        p.start()

    for c in c_threads_list:
        c.join()

    for p in p_threads_list:
        p.join()

print ("The values inside the buffer %s" %(list(queue.queue)))